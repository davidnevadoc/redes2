.TH "includes/ircserver.h" 3 "Wed Apr 26 2017" "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
includes/ircserver.h \- 
Biblioteca de semaforos\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <redes2/irc\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <syslog\&.h>\fP
.br
\fC#include <strings\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <sys/socket\&.h>\fP
.br
\fC#include <arpa/inet\&.h>\fP
.br
\fC#include <pthread\&.h>\fP
.br
\fC#include 'utilities\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fB_data\fP"
.br
.RI "\fIEstructura para el paso de parametros a la funcion de los hilos\&. \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBSERV_NAME\fP   'valknutserver'"
.br
.ti -1c
.RI "#define \fBUSERLEN\fP   16"
.br
.ti -1c
.RI "#define \fBNICKLEN\fP   10"
.br
.ti -1c
.RI "#define \fBMAXUSERS\fP   512"
.br
.ti -1c
.RI "#define \fBOK\fP   0"
.br
.ti -1c
.RI "#define \fBERROR\fP   -1"
.br
.ti -1c
.RI "#define \fBNULL_PARAM\fP   -2"
.br
.ti -1c
.RI "#define \fBNOT_FOUND\fP   -3"
.br
.ti -1c
.RI "#define \fBLONGNICK\fP   -4"
.br
.ti -1c
.RI "#define \fBLONGUSER\fP   -5"
.br
.ti -1c
.RI "#define \fBNOTCREATED\fP   -6"
.br
.ti -1c
.RI "#define \fBERR_MALLOC\fP   -7"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fB_data\fP \fBdata\fP"
.br
.RI "\fIEstructura para el paso de parametros a la funcion de los hilos\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBinit_var\fP (void)"
.br
.RI "\fIFunción que reserva memoria para las estructuras globales\&. \fP"
.ti -1c
.RI "int \fBset_user\fP (int sockfd, char *user)"
.br
.RI "\fIAsigna un nuevo nombre de usuario al socket sockfd\&. \fP"
.ti -1c
.RI "int \fBset_nick\fP (int sockfd, char *nick)"
.br
.RI "\fIAsigna un nuevo nick al socket sockfd\&. \fP"
.ti -1c
.RI "int \fBget_sock_by_nick\fP (char *nick)"
.br
.RI "\fIDevuelve el socket de un usuario identificado por su nick\&. \fP"
.ti -1c
.RI "int \fBget_sock_by_user\fP (char *user)"
.br
.RI "\fIDevuelve el socket de un usuario identificado por su nick\&. \fP"
.ti -1c
.RI "char * \fBget_nick\fP (int sockfd)"
.br
.RI "\fIDevuelve el nick del usuario asgnado a un socket\&. \fP"
.ti -1c
.RI "char * \fBget_user\fP (int sockfd)"
.br
.RI "\fIDevuelve el nombre de usuario del usuario asgnado a un socket\&. \fP"
.ti -1c
.RI "void \fBfree_all\fP (void)"
.br
.RI "\fILibera todos los recursos utilizados\&. \fP"
.ti -1c
.RI "char * \fBget_host\fP (int *sockfd)"
.br
.RI "\fIDevuelve el host asociado al socket\&. \fP"
.ti -1c
.RI "long \fBComplexUser_bySocket\fP (char **prefix, int *psocket)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Biblioteca de semaforos\&. 

Cabecera de \fBircserver\&.c\fP 
.SH "AUTHOR"
.PP
Maria Prieto 
.SH "AUTHOR"
.PP
David Nevado Catalan david.nevadoc@estudiante.uam.es 
.SH "DATE"
.PP
12/02/2017 
.SH "Function Documentation"
.PP 
.SS "long ComplexUser_bySocket (char **prefix, int *psocket)"
Wrapper para la funcion IRC_ComplexUser1459\&. Devuelve el prefijo de un usuario utilizando unicamente el identificador del socket  Devuelve el prfijo de un usuario asociado a un socket 
.PP
\fBParameters:\fP
.RS 4
\fIprefix\fP Puntero a la cadena de caracteres donde se almacena el prefijo obtenido, es decir, el prefijo asociado al socket psocket Puntero al socket del usuario cuyo prefijo se quiere obtener  se devuelve el codigo de control de la funcion IRC_COmplexUser1459 
.RE
.PP

.SS "void free_all (void)"

.PP
Libera todos los recursos utilizados\&. Libera la lista de usuarios y nicks asi como las estructuras mutex 
.SS "char* get_host (int *sockfd)"

.PP
Devuelve el host asociado al socket\&. Devuelve el host asociado a un socket, reserva memoria para la cadena de caracteres devuelta\&. Es decir, esta debera ser liberada posteriormente 
.PP
\fBParameters:\fP
.RS 4
\fIsockfd\fP Puntero al socket 
.RE
.PP
.SH "RETURN"
.PP
host asociao a socketfd 
.SS "char* get_nick (intsockfd)"

.PP
Devuelve el nick del usuario asgnado a un socket\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsockfd\fP socket que identifica al usuario 
.RE
.PP
.SH "RETURN"
.PP
aux nick solicitado, NULL si no se encontro 
.SS "int get_sock_by_nick (char *nick)"

.PP
Devuelve el socket de un usuario identificado por su nick\&. En caso de que hubiera dos usuarios con el mismo nick (no deberia pasar) devuelve el primero que encuentre
.PP
\fBParameters:\fP
.RS 4
\fInick\fP nick del usuario cuyo socket queremos conseguir 
.RE
.PP
.SH "RETURN"
.PP
i socket del usuario, NOT_FOUND si no se encontro ningun usuario con el nick especificado 
.SS "int get_sock_by_user (char *user)"

.PP
Devuelve el socket de un usuario identificado por su nick\&. En caso de que hubiera dos usuarios con el mismo nombre de usuario (no deberia pasar) devuelve el primero que encuentre
.PP
\fBParameters:\fP
.RS 4
\fIuser\fP nombre del usuario cuyo socket queremos conseguir 
.RE
.PP
.SH "RETURN"
.PP
i socket del usuario, NOT_FOUND si no se encontro ningun usuario especificado 
.SS "char* get_user (intsockfd)"

.PP
Devuelve el nombre de usuario del usuario asgnado a un socket\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsockfd\fP socket que identifica al usuario 
.RE
.PP
.SH "RETURN"
.PP
aux nombre de usuario solicitado, NULL si no se encontro 
.SS "int init_var (void)"

.PP
Función que reserva memoria para las estructuras globales\&. 
.SH "RETURN"
.PP
OK si todo fue bien, ERROR si se produjo algun error 
.SS "int set_nick (intsockfd, char *nick)"

.PP
Asigna un nuevo nick al socket sockfd\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsockfd\fP socket que identifica al usuario 
.br
\fInick\fP nuevo nick para el usuario 
.RE
.PP
.SH "RETURN"
.PP
OK si todo fue bien, codigo de error <0 en otro caso 
.SS "int set_user (intsockfd, char *user)"

.PP
Asigna un nuevo nombre de usuario al socket sockfd\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsockfd\fP socket que identifica al usuario 
.br
\fIuser\fP nuevo nombre para el usuario 
.RE
.PP
.SH "RETURN"
.PP
OK si todo fue bien, codigo de error <0 en otro caso 
.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
